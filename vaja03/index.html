<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Three.js particle Collision with Bouncing</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="js/libs/three.min.js"></script>
  <script src="js/controls/OrbitControls.js"></script>
  
  <script>
    // Initialize Three.js
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setClearColor(0x888888); // Set background color to gray
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create a cube
    const cubeSize = 200;
    const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
    const cubeMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
    // const materials = [
    //   new THREE.MeshBasicMaterial({ color: 0xff0000 }), // Red - 2
    //   new THREE.MeshBasicMaterial({ color: 0x00ff00 }), // Green - 0
    //   new THREE.MeshBasicMaterial({ color: 0x0000ff }), // Blue
    //   new THREE.MeshBasicMaterial({ color: 0xffff00 }), // Yellow - 4
    //   new THREE.MeshBasicMaterial({ color: 0xff00ff }), // Magenta
    //   new THREE.MeshBasicMaterial({ color: 0x00ffff }), // Cyan
    // ];

    // const facesToFlip = [1, 3];
    // // Loop through each face of the geometry
    // cubeGeometry.faces.forEach((face, index) => {
    //     if (facesToFlip.includes(index)) {
    //         const temp = face.a;
    //         face.a = face.c;
    //         face.c = temp;
    //     }
    // });

    // // Update the face normals and vertex normals
    // cubeGeometry.computeFaceNormals();
    // cubeGeometry.computeVertexNormals();

    const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    scene.add(cube);


    var buffgeoBack = new THREE.IcosahedronBufferGeometry(3000, 2);
    var matBack = new THREE.MeshBasicMaterial({
        color: 0x000000,
        side: THREE.BackSide
    });
    var back = new THREE.Mesh(buffgeoBack, matBack);
    scene.add(back);

    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(0, 1, 0); // Set light direction
    scene.add(directionalLight);

    camera.position.set(300, 100, 0);

    // Create OrbitControls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    const initialNumberOfMeshes = 40;
    const particles = [];
    const randomSpawnPos = false;
    const killAfterTime = false;
    const maxTime = 10000;
    class Particle {
        constructor() {
            this.mesh = this.spawnMesh();
            if (killAfterTime){
              this.timer = setTimeout(() => this.despawnMesh(), this.getRandomTime());
            }
        }

        spawnMesh() {
          const particleRadius = 5;
          const particleGeometry = new THREE.SphereGeometry(particleRadius, 32, 32);
          const particleMaterial = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
          const mesh = new THREE.Mesh(particleGeometry, particleMaterial);
          

          if (randomSpawnPos){
            // Random initial position within the cube
            mesh.position.x = (Math.random() - 0.5) * cubeSize;
            mesh.position.y = (Math.random() - 0.5) * cubeSize;
            mesh.position.z = (Math.random() - 0.5) * cubeSize;
          } else {
            // Random initial position within the cube
            mesh.position.x = (Math.random() - 0.5) * cubeSize / 16;
            mesh.position.y = (Math.random() - 0.5) * cubeSize / 16;
            mesh.position.z = (Math.random() - 0.5) * cubeSize / 16;

          }

          // Random initial velocity
          mesh.velocity = new THREE.Vector3(
            Math.random() * 0.2 - 0.1,
            Math.random() * 0.2 - 0.1,
            Math.random() * 0.2 - 0.1
          );

          scene.add(mesh);
          return mesh;
        }

        despawnMesh() {
            scene.remove(this.mesh);
            clearTimeout(this.timer);
            // Additional cleanup if needed
            // Spawn a new mesh and start a new timer
            particles.push(new Particle());
        }

        getRandomTime() {
            return Math.random() * maxTime + 2000; // Random time between 2 and 7 seconds
        }
    }
    
    // Initial spawning of meshes
    for (let i = 0; i < initialNumberOfMeshes; i++) {
        particles.push(new Particle());
    }

    const gravity = new THREE.Vector3(0,-0.00001,0);
    const k = 0.5; 
    const alpha = 1.5;
    const beta = 0.1;
    let prevTime = performance.now();
    const hardBorders = false;
    const particleAttract = true;
    const useNorm = false;
    // Main render loop
    const animate = (time) => {

      requestAnimationFrame(animate);

      time = performance.now();

      const deltaTime = time - prevTime;
      if (deltaTime != NaN){

        particles.forEach(particleObj01 => {
          let particle01 = particleObj01.mesh;
          // New VELOCITY
          let trueGravity = gravity.clone().multiplyScalar(deltaTime);
          particle01.velocity.add(trueGravity);

          // COLLISION DETECTION
          if (hardBorders){
            particles.forEach(particleObj02 => {
              if (particleObj01 !== particleObj02){
                let particle02 = particleObj02.mesh;
                const posDiff = particle01.position.clone().sub(particle02.position);
                const velDiff = particle01.velocity.clone().sub(particle02.velocity);
                let collisionPossible = posDiff.dot(velDiff) < 0;
                if (collisionPossible){
                  const centerDifference = particle02.position.clone().sub(particle01.position);
                  const distance = centerDifference.length();
  
                  let didCollide = distance < particle01.geometry.parameters.radius + particle02.geometry.parameters.radius;
                  if (didCollide){
                    const normal = posDiff.clone().normalize();
                    let dotProduct = particle01.velocity.clone().dot(normal);
                    let supForce = -(1 + k);
                    particle01.velocity.add(normal.clone().multiplyScalar(supForce * dotProduct));
                  }
                }
              }
            });
          } else {
            particles.forEach(particleObj02 => {
              if (particleObj01 !== particleObj02){

                  let particle02 = particleObj02.mesh;
                  let d = new THREE.Vector3(0,0,0);
                  
                  if (particleAttract){
                    const displacement = particle01.position.clone().sub(particle02.position);
                    const magnitude = displacement.length() + 1;
                    const exponent = Math.pow(magnitude, alpha);
                    const d = displacement.divideScalar(exponent);
                  }else {
                    const magnitude = particle01.position.clone().sub(particle02.position).length() + 1;
                    const exponent = Math.pow(magnitude, alpha);
                    const displacement = particle01.position.clone().sub(particle02.position);
                    d.add(displacement.divideScalar(exponent));
                  }

                  const velocity01_t = particle01.velocity.clone();
                  const newVelocity = velocity01_t.clone().multiplyScalar(1 - beta).add(d.clone().multiplyScalar(beta));
                  particle01.velocity.copy(newVelocity);
                }
              }); 
            }
          // BORDER DETECTION
          if (useNorm){
            for (let face = 0; face < 6; face++) {
              let normal = cubeGeometry.faces[face].normal.clone();
              const vertices = cubeGeometry.vertices;
              const vertexIndex = cubeGeometry.faces[face].a;
              const pointOnFace = vertices[vertexIndex];
              const center = particle01.position.clone();
        
              const movingToFace = particle01.velocity.clone().dot(normal) < 0;
              if (movingToFace) {
        
                const planeConst = normal.clone().dot(pointOnFace);
                let distance = normal.clone().dot(center) + planeConst;
        
                // normal.multiplyScalar(-1);
                // const sphereToFaceVector = pointOnFace.clone().sub(center);
                // const sphereToFaceDistance = sphereToFaceVector.dot(normal);

                // // Check if the sphere's center is inside or very close to the face
                // if (Math.abs(sphereToFaceDistance) <= particle01.geometry.parameters.radius) {
                //   let dotProduct = particle01.velocity.clone().dot(normal);
                //   let supForce = -(1 + k);
                //   if (face == 1 || face == 3 || face == 5){
                //     supForce = (1 + k);
                //   } 
                //   particle01.velocity.add(normal.clone().multiplyScalar(supForce * dotProduct));
                // }

                if (distance <= particle01.geometry.parameters.radius) {
                // if (sphereToFaceDistance <= 0) {
                  let dotProduct = particle01.velocity.clone().dot(normal);
                  let supForce = -(1 + k);
                  particle01.velocity.add(normal.clone().multiplyScalar(supForce * dotProduct));
                }
              }
            }
          } else {
            if (hardBorders){
              let dotProduct = new THREE.Vector3(0, 0, 0);
              let normal = new THREE.Vector3(0, 0, 0);
              if (Math.abs(particle01.position.x) >= cubeSize / 2) {
                  particle01.velocity.x *= -1;
                  dotProduct.x = -1 * particle01.velocity.x;
                  normal.x = -1;
              }
              if (Math.abs(particle01.position.y) >= cubeSize / 2) {
                particle01.velocity.y *= -1;
                dotProduct.y = -1 * particle01.velocity.y;
                normal.y = -1;
              }
              if (Math.abs(particle01.position.z) >= cubeSize / 2) {
                particle01.velocity.z *= -1;
                dotProduct.z = -1 * particle01.velocity.z;
                normal.z = -1;
              }
              dotProduct = particle01.velocity.clone().dot(normal);
              let supForce = -(1 + k);
              //particle01.velocity.sub(supForce);
              //particle01.velocity.add(normal.clone().multiplyScalar(supForce * dotProduct));
            } else {
              
              
              if (Math.abs(particle01.position.x) >= cubeSize / 2) {
                particle01.velocity.x *= -1;
              }
              if (Math.abs(particle01.position.y) >= cubeSize / 2) {
                particle01.velocity.y *= -1;
              }
              if (Math.abs(particle01.position.z) >= cubeSize / 2) {
                particle01.velocity.z *= -1;
              }
              
              // for (let face = 0; face < 6; face++) {
              //   const up = particle01.position.clone(); 
              //   const uq = cubeGeometry.faces[face].normal.clone();
              //   const d = new THREE.Vector3(0, 0, 0);

              //   const distance = up.clone().sub(uq).length() + 1;

              //   const d_ = up.clone().sub(uq).multiplyScalar(1 / Math.pow(distance, alpha));

              //   d.add(d_);

              //   const velocity01_t = particle01.velocity.clone();
              //   const newVelocity = velocity01_t.clone().multiplyScalar(1 - beta).add(d.clone().multiplyScalar(beta));
              //   particle01.velocity.copy(newVelocity);
              // }
            }
          }

          // New POSITION
          let trueVelocity = particle01.velocity.clone().multiplyScalar(deltaTime);
          particle01.position.add(trueVelocity);
        });

        prevTime = time;
        renderer.render(scene, camera);
      }

    

    };

    animate();
  </script>
</body>
</html>