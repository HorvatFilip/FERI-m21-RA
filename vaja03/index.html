<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>RA-Vaja03</title>
    <style>
      body {
        margin: 0;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <div>
      <span id="fps_display"></span>
      <form id="configForm">
        <label for="updateFps">Update Fps:</label>
        <input type="checkbox" id="updateFps" name="updateFps" checked /><br />

        <label for="hardBorders">Hard Borders:</label>
        <input
          type="checkbox"
          id="hardBorders"
          name="hardBorders"
          checked
        /><br />

        <label for="popSize">Population Size (int):</label>
        <input type="number" id="popSize" name="popSize" value="40" /><br />

        <label for="gravity">Gravity (float):</label>
        <input
          type="number"
          step="0.0001"
          id="gravity"
          name="gravity"
          value="-0.0006"
        /><br />

        <label for="k">K Value (float):</label>
        <input type="number" step="0.1" id="k" name="k" value="0.7" /><br />

        <label for="alpha">Alpha Value (float):</label>
        <input
          type="number"
          step="0.1"
          id="alpha"
          name="alpha"
          value="2"
        /><br />

        <label for="beta">Beta Value (float):</label>
        <input
          type="number"
          step="0.1"
          id="beta"
          name="beta"
          value="0.1"
        /><br />

        <label for="randomSpawn">Random Spawn:</label>
        <input type="checkbox" id="randomSpawn" name="randomSpawn" /><br />

        <label for="killAfterTime">Kill After Time:</label>
        <input
          type="checkbox"
          id="killAfterTime"
          name="killAfterTime"
          checked
        /><br />

        <label for="maxTime">Max Time (int):</label>
        <input type="number" id="maxTime" name="maxTime" value="5000" /><br />

        <button type="submit">Apply Configuration</button>
      </form>
    </div>
    <div id="WebGL-output" ,style="heigh:100px;"></div>
    <script src="js/libs/three.min.js"></script>
    <script src="js/controls/OrbitControls.js"></script>

    <script>
      let fps_display = document.getElementById("fps_display");
      const configForm = document.getElementById("configForm");

      // INIT Three.js
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );

      const renderer = new THREE.WebGLRenderer();
      renderer.setClearColor(0x888888);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      camera.position.set(300, 100, 0);

      // OrbitControls
      const controls = new THREE.OrbitControls(camera, renderer.domElement);

      // BACKGROUND
      var buffgeoBack = new THREE.IcosahedronBufferGeometry(3000, 2);
      var matBack = new THREE.MeshBasicMaterial({
        color: 0x000000,
        side: THREE.BackSide,
      });
      var back = new THREE.Mesh(buffgeoBack, matBack);
      scene.add(back);

      // LIGHT SOURCE
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(0, 1, 0);
      scene.add(directionalLight);

      // BORDER CUBE
      const cubeSize = 180;
      const cubeGeometry = new THREE.BoxGeometry(cubeSize, cubeSize, cubeSize);
      const cubeMaterial = new THREE.MeshBasicMaterial({
        color: 0x00ff00,
        wireframe: true,
      });
      // const materials = [
      //   new THREE.MeshBasicMaterial({ color: 0xff0000 }), // Red - 2
      //   new THREE.MeshBasicMaterial({ color: 0x00ff00 }), // Green - 0
      //   new THREE.MeshBasicMaterial({ color: 0x0000ff }), // Blue
      //   new THREE.MeshBasicMaterial({ color: 0xffff00 }), // Yellow - 4
      //   new THREE.MeshBasicMaterial({ color: 0xff00ff }), // Magenta
      //   new THREE.MeshBasicMaterial({ color: 0x00ffff }), // Cyan
      // ];

      // const facesToFlip = [1, 3];
      // // Loop through each face of the geometry
      // cubeGeometry.faces.forEach((face, index) => {
      //     if (facesToFlip.includes(index)) {
      //         const temp = face.a;
      //         face.a = face.c;
      //         face.c = temp;
      //     }
      // });

      // // Update the face normals and vertex normals
      // cubeGeometry.computeFaceNormals();
      // cubeGeometry.computeVertexNormals();

      const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
      scene.add(cube);

      let randomSpawnPos = false;
      let killAfterTime = true;
      let maxTime = 5000;
      let particles = [];
      class Particle {
        constructor() {
          this.mesh = this.spawnMesh();
          if (killAfterTime) {
            this.timer = setTimeout(
              () => this.despawnMesh(true),
              this.getRandomTime()
            );
          }
        }
        getRandomTime() {
          return Math.random() * maxTime + 2000;
        }

        spawnMesh() {
          const particleRadius = 4;
          const particleGeometry = new THREE.SphereGeometry(
            particleRadius,
            32,
            32
          );
          const particleMaterial = new THREE.MeshLambertMaterial({
            color: Math.random() * 0xffffff,
          });
          const mesh = new THREE.Mesh(particleGeometry, particleMaterial);

          // Random initial position within the cube
          if (randomSpawnPos) {
            mesh.position.x = (Math.random() - 0.5) * cubeSize;
            mesh.position.y = (Math.random() - 0.5) * cubeSize;
            mesh.position.z = (Math.random() - 0.5) * cubeSize;
          } else {
            mesh.position.x = ((Math.random() - 0.5) * cubeSize) / 16;
            mesh.position.y = ((Math.random() - 0.5) * cubeSize) / 16;
            mesh.position.z = ((Math.random() - 0.5) * cubeSize) / 16;
          }

          // Random initial velocity
          mesh.velocity = new THREE.Vector3(
            Math.random() * 0.2 - 0.1,
            Math.random() * 0.2 - 0.1,
            Math.random() * 0.2 - 0.1
          );

          scene.add(mesh);
          return mesh;
        }

        despawnMesh(respawn) {
          scene.remove(this.mesh);
          clearTimeout(this.timer);
          if (respawn) {
            particles.push(new Particle());
          }
        }
      }

      let gravity = new THREE.Vector3(0, -0.0006, 0);
      // const gravity = new THREE.Vector3(0, 0, 0);
      let popSize = 40;
      let k = 0.7;
      let alpha = 2;
      let beta = 0.1;
      let hardBorders = true;
      let particleAttract = false;
      let updateFps = true;

      let config = {
        updateFps: true,
        hardBorders: true,
        popSize: 50,
        gravity: -0.0006,
        k: 0.7,
        alpha: 2,
        beta: 0.1,
        randomSpawnPos: false,
        killAfterTime: true,
        maxTime: 5000,
      };

      class ParticleSimulation {
        constructor(conf) {
          particles = [];
          this.loadConfig(conf);
        }

        loadConfig(conf) {
          updateFps = conf.updateFps;
          // PARTICLE
          randomSpawnPos = conf.randomSpawnPos;
          killAfterTime = conf.killAfterTime;
          maxTime = conf.maxTime;
          // COLLISION
          hardBorders = conf.hardBorders;
          popSize = conf.popSize;
          gravity = new THREE.Vector3(0, conf.gravity, 0);
          k = conf.k;
          alpha = conf.alpha;
          beta = conf.beta;

          if (particles.length > 0) {
            particles.forEach((particle) => {
              particle.despawnMesh(false);
            });
          }
          for (let i = 0; i < popSize; i++) {
            particles.push(new Particle());
          }
        }
      }
      const SIM = new ParticleSimulation(config);

      configForm.addEventListener("submit", function (event) {
        event.preventDefault();

        const formData = new FormData(configForm);

        const configuration = {
          updateFps: formData.get("updateFps") === "on",
          hardBorders: formData.get("hardBorders") === "on",
          popSize: parseInt(formData.get("popSize")),
          gravity: parseFloat(formData.get("gravity")),
          k: parseFloat(formData.get("k")),
          alpha: parseFloat(formData.get("alpha")),
          beta: parseFloat(formData.get("beta")),
          randomSpawnPos: formData.get("randomSpawn") === "on",
          killAfterTime: formData.get("killAfterTime") === "on",
          maxTime: parseInt(formData.get("maxTime")),
        };

        SIM.loadConfig(configuration);
      });

      let fps = 0;
      setInterval(() => {
        if (updateFps) {
          fps_display.textContent = Math.floor(fps);
        }
      }, 500);
      // Main render loop
      let prevTime = performance.now();
      const animate = (time) => {
        requestAnimationFrame(animate);

        time = performance.now();

        const deltaTime = time - prevTime;
        if (deltaTime != NaN) {
          if (updateFps) {
            fps = 1 / (deltaTime / 1000);
          }

          particles.forEach((particleObj01) => {
            let particle01 = particleObj01.mesh;

            // New VELOCITY
            let trueGravity = gravity.clone().multiplyScalar(deltaTime);
            particle01.velocity.add(trueGravity);

            // COLLISION DETECTION
            if (hardBorders) {
              particles.forEach((particleObj02) => {
                if (particleObj01 !== particleObj02) {
                  let particle02 = particleObj02.mesh;
                  const posDiff = particle01.position
                    .clone()
                    .sub(particle02.position);
                  const velDiff = particle01.velocity
                    .clone()
                    .sub(particle02.velocity);

                  // (u1−u2)⋅( v 1−v 2)<0
                  let collisionPossible = posDiff.dot(velDiff) < 0;
                  if (collisionPossible) {
                    const centerDifference = particle02.position
                      .clone()
                      .sub(particle01.position);
                    const distance = centerDifference.length();

                    let didCollide =
                      distance <
                      particle01.geometry.parameters.radius +
                        particle02.geometry.parameters.radius;
                    if (didCollide) {
                      // n=(up−uq)/(‖up−uq‖+1)
                      const magnitude = posDiff.length();
                      const normal = posDiff.divideScalar(magnitude);

                      // v1(ti+1)=v1(ti)−(1+k)(v1(ti)⋅n2)n2
                      let dotProduct = particle01.velocity.clone().dot(normal);
                      let supForce = -(1 + k);
                      particle01.velocity.add(
                        normal.clone().multiplyScalar(supForce * dotProduct)
                      );
                    }
                  }
                }
              });
            } else {
              particles.forEach((particleObj02) => {
                if (particleObj01 !== particleObj02) {
                  let particle02 = particleObj02.mesh;
                  const posDiff = particle01.position
                    .clone()
                    .sub(particle02.position);
                  const velDiff = particle01.velocity
                    .clone()
                    .sub(particle02.velocity);

                  let collisionPossible = posDiff.dot(velDiff) < 0;
                  if (collisionPossible || true) {
                    let d = new THREE.Vector3(0, 0, 0);

                    if (particleAttract) {
                      const positionDifference = particle02.position
                        .clone()
                        .sub(particle01.position);
                      const distance = positionDifference.length();

                      const forceMagnitude =
                        k *
                        positionDifference.divideScalar(
                          Math.pow(distance, alpha) + 1
                        );
                      const attractionForce = positionDifference
                        .normalize()
                        .multiplyScalar(forceMagnitude);

                      const velocity01_t = particle01.velocity.clone();
                      const newVelocity = velocity01_t
                        .clone()
                        .multiplyScalar(1 - beta)
                        .add(attractionForce.clone().multiplyScalar(beta));
                      particle01.velocity.copy(newVelocity);
                    } else {
                      // d=d+(up−uq)/pow((‖up−uq‖+1),α)
                      const magnitude = posDiff.length() + 1;
                      const exponent = Math.pow(magnitude, alpha);
                      d.add(posDiff.divideScalar(exponent));

                      // vp(t+1)=(1−β)vp(t)+βd
                      const velocity01_t = particle01.velocity.clone();
                      const newVelocity = velocity01_t
                        .clone()
                        .multiplyScalar(1 - beta)
                        .add(d.clone().multiplyScalar(beta));
                      particle01.velocity.copy(newVelocity);
                    }
                  }
                }
              });
            }
            // BORDER DETECTION
            if (hardBorders) {
              for (let face = 0; face < 12; face += 2) {
                let normal = cubeGeometry.faces[face].normal.clone();
                const vertices = cubeGeometry.vertices;
                const vertexIndex = cubeGeometry.faces[face].a;
                const pointOnFace = vertices[vertexIndex];
                const center = particle01.position.clone();

                const movingToFace =
                  particle01.velocity.clone().dot(normal) < 0;
                if (movingToFace) {
                  const planeConst = normal.clone().dot(pointOnFace);
                  let distance = normal.clone().dot(center) + planeConst;

                  if (distance <= particle01.geometry.parameters.radius) {
                    let dotProduct = particle01.velocity.clone().dot(normal);
                    let supForce = -(1 + k);
                    particle01.velocity.add(
                      normal.clone().multiplyScalar(supForce * dotProduct)
                    );
                  }
                }
              }
            } else {
              for (let face = 0; face < 12; face += 2) {
                let normal = cubeGeometry.faces[face].normal.clone();
                const vertices = cubeGeometry.vertices;
                const vertexIndex = cubeGeometry.faces[face].a;
                const pointOnFace = vertices[vertexIndex];
                const center = particle01.position.clone();

                const movingToFace =
                  particle01.velocity.clone().dot(normal) < 0;
                if (movingToFace) {
                  const planeConst = normal.clone().dot(pointOnFace);
                  let distance = normal.clone().dot(center) + planeConst;

                  if (distance <= particle01.geometry.parameters.radius) {
                    let dotProduct = particle01.velocity.clone().dot(normal);
                    let supForce = -(1 + k);
                    particle01.velocity.add(
                      normal.clone().multiplyScalar(supForce * dotProduct)
                    );
                  }
                  // particleObj01.despawnMesh();
                  // let d = new THREE.Vector3(0, 0, 0);
                  // const magnitude =
                  //   particle01.position.clone().sub(normal).length() + 1;
                  // const exponent = Math.pow(magnitude, alpha);
                  // const displacement = particle01.position
                  //   .clone()
                  //   .sub(normal);
                  // d.add(displacement.divideScalar(exponent));
                  // const velocity01_t = particle01.velocity.clone();
                  // const newVelocity = velocity01_t
                  //   .clone()
                  //   .multiplyScalar(1 - beta)
                  //   .add(d.clone().multiplyScalar(beta));
                  // particle01.velocity.copy(newVelocity);
                  // const reflection = particle01.velocity
                  //   .clone()
                  //   .reflect(normal);
                  // particle01.velocity.copy(reflection);
                }
              }
            }

            // New POSITION
            let trueVelocity = particle01.velocity
              .clone()
              .multiplyScalar(deltaTime);
            particle01.position.add(trueVelocity);
          });

          prevTime = time;
          renderer.render(scene, camera);
        }
      };

      animate();
    </script>
  </body>
</html>
